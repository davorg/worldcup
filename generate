#!/usr/bin/perl

use strict;
use warnings;
use feature 'say';

use Time::Piece;
use JSON;

my $json = JSON->new->pretty->utf8;

open my $d_fh, '>', 'docs/js/data.js' or die "$!";

open my $s_fh, '<', 'stadiums.csv' or die "$!";

my ($stadiums, $stadiums_lookup);

my @cols = qw[code name city utcoffset timezone];

while (<$s_fh>) {
  chomp;
  my %stad;
  @stad{@cols} = split /,/;
  $stadiums_lookup->{$stad{code}} = \%stad;
  push @$stadiums, \%stad;
}

say $d_fh 'var stadiums = '        . $json->encode($stadiums) . ";\n";
say $d_fh 'var stadiums_lookup = ' . $json->encode($stadiums_lookup) . ";\n";

open my $g_fh, '<', 'games.csv' or die "$!";

my ($games, $teams, $rounds);

@cols = qw[description date stadium team1 team2 group result];

while (<$g_fh>) {
  chomp;
  my %game;
  @game{@cols} = split /,/;

  $game{description} = $game{group} if $game{description} !~ /\D/;
  $rounds->{$game{description}} = 1;

  $game{date} = Time::Piece->strptime($game{date}, '%d/%m/%Y %H:%M')->datetime;

  my @classes = ($game{description}, $game{stadium});
  push @classes, grep{  !/^(Winner|Runner|To be)/ }
		 @game{qw[team1 team2]};

  $game{class} = join ' ', map { to_class($_) } @classes;

  push @$games, \%game;

  for my $t (qw[team1 team2]) {
    next if $game{$t} =~ /^(Winner|Runner|To be)/;
    $teams->{$game{$t}}++;
  }
}

say $d_fh 'var rounds = ' . $json->encode([ map { { $_ => to_class($_} }} sort keys %$rounds ]) . ";\n";
say $d_fh 'var games = ' . $json->encode($games) . ";\n";
say $d_fh 'var teams = ' . $json->encode([map { { $_ => to_class($_) } } sort keys %$teams ]) . ";\n";

sub to_class {
  my $in = shift;
  $in =~ s/\s+/-/g;
  return lc $in;
}
